// Жизнен цикъл на обектите | Копиране



// 10.5. Задача 2.2.44. (асоциативен масив) [7] Да се дефинира клас Dictionary,
// който създава тълковен речник. Тълковният речник се състои от не по-
// вече от 500 двойки дума–тълкувание, като думата е символен низ с не
// повече от 100 символа, а тълкованието е символен низ с не повече от 500
// символа.
// • Да се дефинира подходяща структура, описваща една двойка дума-
// тълкувание;
// • Да се дефинират подходящи член-данни на клас Dictionary;
// Клас Dictionary да съдържа методи, с които може да се извършват
// следните операции над речника:
// • Инициализация на празен речник;
// • извеждане на всички думи в речника и техните тълкувания;
// • включване на нова двойка дума–тълкуване в речника;
// • изключване на двойка дума–тълкуване от речника (по дадена ду-
// ма);
// • търсене на значението на дадена дума в речник.
// • извеждане на всички думи в речника и техните тълкувания по аз-
// бучен ред на думите;
// Да се дефинира оператор +, обединяващ два речника, такъв че:
// • Ако някои думи имат значение и в двата речника, значенията да
// се конкатенират в резултатния сумарен речник;
// • Ако общият брой на думите в двата речника надхвърля 500, да се
// използват само първите 500 думи (при произволна наредба).
// 10.6. Клас Dictionary от задача 10.5. да се реализира така, че максималният
// брой N на двойки ключ-стойност, които могат да бъдат добавени към
// речника, да се задава като параметър на конструктора на класа. За кла-
// са да се реализират конструктор за копиране, оператор за присвояване
// 51и деструктор.
// Да се реализират оператори за събиране + и +=, обединяващи два реч-
// ника. Ако в речниците a и b има еднакви думи с различни значения, то
// за тези думи в речника a+b да се използва значението им от речника a.
// Да се реализира подходящ тест на класа.
// Някои от следващите задачи са върху примерния шаблон Vector, раз-
// работен на лекции. Шаблонът реализира прост контейнер чрез масив в
// динамичната памет:
// template <typename T>
// class Vector
// {
// public:
// Vector();
// Vector(const Vector<T> &);
// Vector<T>& operator=(const Vector<T> &);
// ~Vector ();
// Vector<T> operator + (const Vector<T> &) const;
// Vector<T>& operator+=(const Vector<T> &);
// T& operator[] (size_t i);
// T operator[](size_t i) const;
// void push (const T& x);
// void print () const;
// size_t size() const;
// private:
// T* elements;
// size_t nCapacity;
// };
// 10.7. За шаблона Vector от лекции да се дефинира метод Vector::resize,
// с който да може динамично да се променя капацитета на масива. При
// намаляване на капацитета да отпадат най-левите елементи на масива.
// При увеличаване на капацитета на масива, новите елементи да остават
// неинициализирани.
// Да се реализират подходящи тестове.

// 10.8. Като се използва шаблона Vector да се създаде масив M то 3 елемента,
// чиито елементи са масиви от по 3 числа от тип double. Да се въведат
// елементите на M от клавиатурата.
// 5210.9. За шаблона на клас Vector от лекции да се дефинира метод:
// Vector<Vector<T>> Vector<T>::slice(size_t n).
// Ако приемем, че изходният масив е с елементи от тип T, то методът
// slice създава и връща масив от масиви, т.е. резултатният масив се със-
// тои от масиви с елементи от тип T.
// Методът да “разделя” изходният масив на равни по големина части с по
// n последователни елемента. i-тият поред масив от резултата съдържа
// i-тата поредна n-торка от последователни членове на изходния масив.
// Последният масив в резултата може да съдържа по-малко от n елемен-
// та, ако броят на елементите на изходният масив не е кратен на n.
// Пример: Нека масивът a има елементите [1,2,3,4,5,6,7,8,10,11]. При
// тези условия, a.slice(3) създава и връща масива от масиви
// [[1,2,3],[4,5,6],[7,8,9],[10,11]].
// Да се напишат подходящи тестове.